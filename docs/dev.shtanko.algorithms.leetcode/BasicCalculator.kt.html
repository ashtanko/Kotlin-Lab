<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BasicCalculator.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kotlab</a> &gt; <a href="index.source.html" class="el_package">dev.shtanko.algorithms.leetcode</a> &gt; <span class="el_source">BasicCalculator.kt</span></div><h1>BasicCalculator.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2020 Oleksii Shtanko
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.shtanko.algorithms.leetcode

import java.util.Stack
import kotlin.math.pow

fun interface CalculationStrategy {
    fun calculate(s: String): Int
}

<span class="fc" id="L26">class StackAndStringReversal : CalculationStrategy {</span>

    private fun evaluateExpr(stack: Stack&lt;Any?&gt;): Int {
<span class="fc" id="L29">        var res = 0</span>
<span class="fc bfc" id="L30" title="All 2 branches covered.">        if (!stack.empty()) {</span>
<span class="fc" id="L31">            res = stack.pop() as Int</span>
        }

        // Evaluate the expression till we get corresponding ')'
<span class="fc bfc" id="L35" title="All 4 branches covered.">        while (!stack.empty() &amp;&amp; stack.peek() as Char != ')') {</span>
<span class="fc" id="L36">            val sign = stack.pop() as Char</span>
<span class="fc bfc" id="L37" title="All 2 branches covered.">            if (sign == '+') {</span>
<span class="fc" id="L38">                res += stack.pop() as Int</span>
            } else {
<span class="fc" id="L40">                res -= stack.pop() as Int</span>
            }
        }
<span class="fc" id="L43">        return res</span>
    }

    override fun calculate(s: String): Int {
<span class="fc" id="L47">        var operand = 0</span>
<span class="fc" id="L48">        var n = 0</span>
<span class="fc" id="L49">        val stack = Stack&lt;Any?&gt;()</span>

<span class="fc bfc" id="L51" title="All 2 branches covered.">        for (i in s.length - 1 downTo 0) {</span>
<span class="fc" id="L52">            val ch: Char = s[i]</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">            if (Character.isDigit(ch)) {</span>
                // Forming the operand - in reverse order.
<span class="fc" id="L55">                operand += DECIMAL.toDouble().pow(n.toDouble()).toInt() * (ch - '0')</span>
<span class="fc" id="L56">                n += 1</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">            } else if (ch != ' ') {</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">                if (n != 0) {</span>
                    // Save the operand on the stack
                    // As we encounter some non-digit.
<span class="fc" id="L61">                    stack.push(operand)</span>
<span class="fc" id="L62">                    n = 0</span>
<span class="fc" id="L63">                    operand = 0</span>
                }
<span class="fc bfc" id="L65" title="All 2 branches covered.">                if (ch == '(') {</span>
<span class="fc" id="L66">                    val res = evaluateExpr(stack)</span>
<span class="fc" id="L67">                    stack.pop()</span>

                    // Append the evaluated result to the stack.
                    // This result could be of a sub-expression within the parenthesis.
<span class="fc" id="L71">                    stack.push(res)</span>
                } else {
                    // For other non-digits just push onto the stack.
<span class="fc" id="L74">                    stack.push(ch)</span>
                }
            }
        }

        // Push the last operand to stack, if any.
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (n != 0) {</span>
<span class="fc" id="L81">            stack.push(operand)</span>
        }

        // Evaluate any left overs in the stack.
<span class="fc" id="L85">        return evaluateExpr(stack)</span>
    }
}

<span class="fc" id="L89">class StackAndNoStringReversal : CalculationStrategy {</span>
    override fun calculate(s: String): Int {
<span class="fc" id="L91">        val stack = Stack&lt;Int&gt;()</span>
<span class="fc" id="L92">        var operand = 0</span>
<span class="fc" id="L93">        var result = 0 // For the on-going result</span>

<span class="fc" id="L95">        var sign = 1 // 1 means positive, -1 means negative</span>

<span class="fc bfc" id="L97" title="All 2 branches covered.">        for (i in s.indices) {</span>
<span class="fc" id="L98">            val ch: Char = s[i]</span>
<span class="fc" id="L99">            when {</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">                Character.isDigit(ch) -&gt; {</span>
                    // Forming operand, since it could be more than one digit
<span class="fc" id="L102">                    operand = DECIMAL * operand + ch.minus('0')</span>
                }

<span class="fc bfc" id="L105" title="All 2 branches covered.">                ch == '+' -&gt; {</span>
                    // Evaluate the expression to the left,
                    // with result, sign, operand
<span class="fc" id="L108">                    result += sign * operand</span>

                    // Save the recently encountered '+' sign
<span class="fc" id="L111">                    sign = 1</span>

                    // Reset operand
<span class="fc" id="L114">                    operand = 0</span>
                }

<span class="fc bfc" id="L117" title="All 2 branches covered.">                ch == '-' -&gt; {</span>
<span class="fc" id="L118">                    result += sign * operand</span>
<span class="fc" id="L119">                    sign = -1</span>
<span class="fc" id="L120">                    operand = 0</span>
                }

<span class="fc bfc" id="L123" title="All 2 branches covered.">                ch == '(' -&gt; {</span>
                    // Push the result and sign on to the stack, for later
                    // We push the result first, then sign
<span class="fc" id="L126">                    stack.push(result)</span>
<span class="fc" id="L127">                    stack.push(sign)</span>

                    // Reset operand and result, as if new evaluation begins for the new sub-expression
<span class="fc" id="L130">                    sign = 1</span>
<span class="fc" id="L131">                    result = 0</span>
                }

<span class="fc bfc" id="L134" title="All 2 branches covered.">                ch == ')' -&gt; {</span>
                    // Evaluate the expression to the left
                    // with result, sign and operand
<span class="fc" id="L137">                    result += sign * operand</span>

                    // ')' marks end of expression within a set of parenthesis
                    // Its result is multiplied with sign on top of stack
                    // as stack.pop() is the sign before the parenthesis
<span class="fc" id="L142">                    result *= stack.pop()</span>

                    // Then add to the next operand on the top.
                    // as stack.pop() is the result calculated before this parenthesis
                    // (operand on stack) + (sign on stack * (result from parenthesis))
<span class="fc" id="L147">                    result += stack.pop()</span>

                    // Reset the operand
<span class="fc" id="L150">                    operand = 0</span>
                }
            }
        }
<span class="fc" id="L154">        return result + sign * operand</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>