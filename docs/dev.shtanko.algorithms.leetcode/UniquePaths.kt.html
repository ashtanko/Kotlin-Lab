<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UniquePaths.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kotlab</a> &gt; <a href="index.source.html" class="el_package">dev.shtanko.algorithms.leetcode</a> &gt; <span class="el_source">UniquePaths.kt</span></div><h1>UniquePaths.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2023 Oleksii Shtanko
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.shtanko.algorithms.leetcode

/**
 * 62. Unique Paths
 * @see &lt;a href=&quot;https://leetcode.com/problems/unique-paths&quot;&gt;leetcode page&lt;/a&gt;
 */
fun interface UniquePaths {
    operator fun invoke(m: Int, n: Int): Int
}

/**
 * Approach 1: Brute-Force
 */
<span class="fc" id="L30">class UniquePathsBruteForce : UniquePaths {</span>
    override fun invoke(m: Int, n: Int): Int {
<span class="fc" id="L32">        return perform(m, n, 0, 0)</span>
    }

    /**
     * Calculate the number of unique paths from the top-left corner (0,0) to the
     * bottom-right corner (m-1, n-1) in a grid of size m x n.
     *
     * @param m The number of rows in the grid.
     * @param n The number of columns in the grid.
     * @param i The current row index.
     * @param j The current column index.
     * @return The number of unique paths from (0,0) to (m-1, n-1).
     */
<span class="nc" id="L45">    private fun perform(m: Int, n: Int, i: Int = 0, j: Int = 0): Int {</span>
        // base case: If the current position is out of bounds, there is no path.
<span class="fc bfc" id="L47" title="All 4 branches covered.">        if (i &gt;= m || j &gt;= n) return 0</span>
        // base case: If we have reached the destination, there is one unique path.
<span class="fc bfc" id="L49" title="All 4 branches covered.">        if (i == m - 1 &amp;&amp; j == n - 1) return 1</span>
        // recursive case: Sum the paths going right and down from the current position.
<span class="fc" id="L51">        return perform(m, n, i + 1, j) + perform(m, n, i, j + 1)</span>
    }
}

/**
 * Approach 2: Dynamic Programming - Memoization
 */
<span class="fc" id="L58">class UniquePathsDpMemo : UniquePaths {</span>
    /**
     * Calculate the number of unique paths from the top-left corner (0,0) to the
     * bottom-right corner (m-1, n-1) in a grid of size m x n using memoization.
     *
     * @param m The number of rows in the grid.
     * @param n The number of columns in the grid.
     * @return The number of unique paths from (0,0) to (m-1, n-1).
     */
    override fun invoke(m: Int, n: Int): Int {
        // Create a HashMap to memoize results.
<span class="fc" id="L69">        val memo = HashMap&lt;Pair&lt;Int, Int&gt;, Int&gt;()</span>

        /**
         * Recursive function to find unique paths.
         *
         * @param i The current row index.
         * @param j The current column index.
         * @return The number of unique paths from (i, j) to (m-1, n-1).
         */
        fun dfs(i: Int, j: Int): Int {
<span class="fc bfc" id="L79" title="All 4 branches covered.">            if (i &gt;= m || j &gt;= n) return 0</span>
<span class="fc bfc" id="L80" title="All 4 branches covered.">            if (i == m - 1 &amp;&amp; j == n - 1) return 1</span>

            // Check if the result for this cell is already memoized.
<span class="fc bfc" id="L83" title="All 2 branches covered.">            if (memo.containsKey(Pair(i, j))) {</span>
<span class="fc" id="L84">                return memo[Pair(i, j)]!!</span>
            }

            // Calculate the number of paths recursively.
<span class="fc" id="L88">            val paths = dfs(i + 1, j) + dfs(i, j + 1)</span>

            // Memoize the result before returning.
<span class="fc" id="L91">            memo[Pair(i, j)] = paths</span>

<span class="fc" id="L93">            return paths</span>
        }

        // Start the calculation from the top-left corner (0,0).
<span class="fc" id="L97">        return dfs(0, 0)</span>
    }
}

/**
 * Approach 3: Dynamic Programming - Tabulation
 */
<span class="fc" id="L104">class UniquePathsDpTabulation : UniquePaths {</span>
    override fun invoke(m: Int, n: Int): Int {
<span class="pc bpc" id="L106" title="1 of 4 branches missed.">        if (m == 0 &amp;&amp; n == 0) return 0</span>
        // Create a 2D array to store the number of unique paths for each cell.
<span class="fc bfc" id="L108" title="All 4 branches covered.">        val dp = Array(m) { IntArray(n) { 1 } }</span>

        // Calculate the number of unique paths using dynamic programming.
<span class="fc bfc" id="L111" title="All 2 branches covered.">        for (i in 1 until m) {</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            for (j in 1 until n) {</span>
<span class="fc" id="L113">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span>
            }
        }

        // The result is stored in the bottom-right corner of the grid.
<span class="fc" id="L118">        return dp[m - 1][n - 1]</span>
    }
}

/**
 * Approach 4: Space Optimized Dynamic Programming
 */
<span class="fc" id="L125">class UniquePathsDpOpt : UniquePaths {</span>
    override fun invoke(m: Int, n: Int): Int {
<span class="pc bpc" id="L127" title="1 of 4 branches missed.">        if (m == 0 &amp;&amp; n == 0) return 0</span>
        // Create an array to store the number of unique paths for each column.
<span class="fc bfc" id="L129" title="All 2 branches covered.">        val dp = IntArray(n) { 1 }</span>

        // Calculate the number of unique paths using dynamic programming.
<span class="fc bfc" id="L132" title="All 2 branches covered.">        for (i in 1 until m) {</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">            for (j in 1 until n) {</span>
<span class="fc" id="L134">                dp[j] += dp[j - 1]</span>
            }
        }

        // The result is stored in the last column of the array.
<span class="fc" id="L139">        return dp[n - 1]</span>
    }
}

/**
 * Approach 5: Math
 */
<span class="fc" id="L146">class UniquePathsMath : UniquePaths {</span>

    override fun invoke(m: Int, n: Int): Int {
<span class="pc bpc" id="L149" title="1 of 4 branches missed.">        if (m == 0 &amp;&amp; n == 0) return 0</span>
<span class="fc" id="L150">        var ans = 1</span>
<span class="fc" id="L151">        var i = m + n - 2</span>
<span class="fc" id="L152">        var j = 1</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        while (i &gt;= maxOf(m, n)) {</span>
<span class="fc" id="L154">            ans = ans * i / j</span>
<span class="fc" id="L155">            i--</span>
<span class="fc" id="L156">            j++</span>
        }
<span class="fc" id="L158">        return ans</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>