<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LargestIsland.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kotlab</a> &gt; <a href="index.source.html" class="el_package">dev.shtanko.algorithms.leetcode</a> &gt; <span class="el_source">LargestIsland.kt</span></div><h1>LargestIsland.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2022 Oleksii Shtanko
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.shtanko.algorithms.leetcode

import java.util.Stack
import kotlin.math.max

/**
 * 827. Making A Large Island
 * @see &lt;a href=&quot;https://leetcode.com/problems/making-a-large-island/&quot;&gt;leetcode page&lt;/a&gt;
 */
fun interface LargestIsland {
    operator fun invoke(grid: Array&lt;IntArray&gt;): Int
}

/**
 * Approach 1: Naive Depth First Search
 */
<span class="fc" id="L33">class LargestIslandDFS : LargestIsland {</span>
<span class="fc" id="L34">    private val dr = intArrayOf(-1, 0, 1, 0)</span>
<span class="fc" id="L35">    private val dc = intArrayOf(0, -1, 0, 1)</span>

    override operator fun invoke(grid: Array&lt;IntArray&gt;): Int {
<span class="fc" id="L38">        val n: Int = grid.size</span>

<span class="fc" id="L40">        var ans = 0</span>
<span class="fc" id="L41">        var hasZero = false</span>
<span class="fc bfc" id="L42" title="All 6 branches covered.">        for (r in 0 until n) for (c in 0 until n) if (grid[r][c] == 0) {</span>
<span class="fc" id="L43">            hasZero = true</span>
<span class="fc" id="L44">            grid[r][c] = 1</span>
<span class="fc" id="L45">            ans = max(ans, check(grid, r, c))</span>
<span class="fc" id="L46">            grid[r][c] = 0</span>
        }

<span class="fc bfc" id="L49" title="All 2 branches covered.">        return if (hasZero) ans else n * n</span>
    }

    fun check(grid: Array&lt;IntArray&gt;, r0: Int, c0: Int): Int {
<span class="fc" id="L53">        val n = grid.size</span>
<span class="fc" id="L54">        val stack: Stack&lt;Int&gt; = Stack()</span>
<span class="fc" id="L55">        val seen: MutableSet&lt;Int&gt; = HashSet()</span>
<span class="fc" id="L56">        stack.push(r0 * n + c0)</span>
<span class="fc" id="L57">        seen.add(r0 * n + c0)</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">        while (!stack.isEmpty()) {</span>
<span class="fc" id="L59">            val code: Int = stack.pop()</span>
<span class="fc" id="L60">            val r = code / n</span>
<span class="fc" id="L61">            val c = code % n</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">            for (k in 0..3) {</span>
<span class="fc" id="L63">                val nr = r + dr[k]</span>
<span class="fc" id="L64">                val nc = c + dc[k]</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">                val isContains = !seen.contains(nr * n + nc)</span>
<span class="fc bfc" id="L66" title="All 10 branches covered.">                val local = nr in 0 until n &amp;&amp; 0 &lt;= nc &amp;&amp; nc &lt; n</span>
<span class="fc bfc" id="L67" title="All 6 branches covered.">                if (isContains &amp;&amp; local &amp;&amp; grid[nr][nc] == 1) {</span>
<span class="fc" id="L68">                    stack.push(nr * n + nc)</span>
<span class="fc" id="L69">                    seen.add(nr * n + nc)</span>
                }
            }
        }
<span class="fc" id="L73">        return seen.size</span>
    }
}

/**
 * Approach #2: Component Sizes
 */
<span class="fc" id="L80">class LargestIslandComponentSizes : LargestIsland {</span>
<span class="fc" id="L81">    private val dr = intArrayOf(-1, 0, 1, 0)</span>
<span class="fc" id="L82">    private val dc = intArrayOf(0, -1, 0, 1)</span>
<span class="fc" id="L83">    private var grid: Array&lt;IntArray&gt; = arrayOf()</span>
    private var n = 0

    override operator fun invoke(grid: Array&lt;IntArray&gt;): Int {
<span class="fc" id="L87">        this.grid = grid</span>
<span class="fc" id="L88">        n = grid.size</span>

<span class="fc" id="L90">        var index = 2</span>
<span class="fc" id="L91">        val area = IntArray(n * n + 2)</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for (r in 0 until n) {</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">            for (c in 0 until n) {</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">                if (grid[r][c] == 1) {</span>
<span class="fc" id="L95">                    area[index] = dfs(r, c, index++)</span>
                }
            }
        }

<span class="fc" id="L100">        var ans = 0</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        for (x in area) ans = max(ans, x)</span>
<span class="fc bfc" id="L102" title="All 6 branches covered.">        for (r in 0 until n) for (c in 0 until n) if (grid[r][c] == 0) {</span>
<span class="fc" id="L103">            val seen: MutableSet&lt;Int&gt; = HashSet()</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">            for (move in neighbors(r, c)) {</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">                if (grid[move / n][move % n] &gt; 1) {</span>
<span class="fc" id="L106">                    seen.add(grid[move / n][move % n])</span>
                }
            }
<span class="fc" id="L109">            var bns = 1</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            for (i in seen) {</span>
<span class="fc" id="L111">                bns += area[i]</span>
            }
<span class="fc" id="L113">            ans = max(ans, bns)</span>
        }

<span class="fc" id="L116">        return ans</span>
    }

    private fun dfs(r: Int, c: Int, index: Int): Int {
<span class="fc" id="L120">        var ans = 1</span>
<span class="fc" id="L121">        grid[r][c] = index</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (move in neighbors(r, c)) {</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">            if (grid[move / n][move % n] == 1) {</span>
<span class="fc" id="L124">                grid[move / n][move % n] = index</span>
<span class="fc" id="L125">                ans += dfs(move / n, move % n, index)</span>
            }
        }
<span class="fc" id="L128">        return ans</span>
    }

    private fun neighbors(r: Int, c: Int): List&lt;Int&gt; {
<span class="fc" id="L132">        val ans: MutableList&lt;Int&gt; = ArrayList()</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        for (k in 0..3) {</span>
<span class="fc" id="L134">            val nr = r + dr[k]</span>
<span class="fc" id="L135">            val nc = c + dc[k]</span>
<span class="fc bfc" id="L136" title="All 10 branches covered.">            if (nr in 0 until n &amp;&amp; 0 &lt;= nc &amp;&amp; nc &lt; n) {</span>
<span class="fc" id="L137">                ans.add(nr * n + nc)</span>
            }
        }
<span class="fc" id="L140">        return ans</span>
    }
}

<span class="fc" id="L144">class LargestIslandUnionFind : LargestIsland {</span>
    override operator fun invoke(grid: Array&lt;IntArray&gt;): Int {
<span class="fc" id="L146">        val rows: Int = grid.size</span>
<span class="fc" id="L147">        val cols: Int = grid.first().size</span>

        // create father array and size array, and initialize them
<span class="fc" id="L150">        val father = IntArray(rows * cols)</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (i in 0 until rows * cols) {</span>
<span class="fc" id="L152">            father[i] = i</span>
        }
<span class="fc bfc" id="L154" title="All 2 branches covered.">        val size = IntArray(rows * cols) { 1 }</span>

<span class="fc" id="L156">        val dx = intArrayOf(0, 1, -1, 0)</span>
<span class="fc" id="L157">        val dy = intArrayOf(1, 0, 0, -1)</span>

<span class="fc" id="L159">        scanGrid(rows, cols, grid, dx, dy, father, size)</span>

        // find current max component size
<span class="fc" id="L162">        val max = findMaxComponent(rows, cols, grid, dx, dy, father, size)</span>

        // return whole size if the grid is an all 1 matrix, otherwise return the value of max
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        return if (max == 0) rows * cols else max</span>
    }

    private fun findMaxComponent(
        rows: Int,
        cols: Int,
        grid: Array&lt;IntArray&gt;,
        dx: IntArray,
        dy: IntArray,
        father: IntArray,
        size: IntArray,
    ): Int {
<span class="fc" id="L177">        var max = 0</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        for (i in size.indices) {</span>
<span class="fc" id="L179">            max = max(max, size[i])</span>
        }
        // find max component size if we set any 0 to 1
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (i in 0 until rows) {</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">            for (j in 0 until cols) {</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                if (grid[i][j] == 0) {</span>
<span class="fc" id="L185">                    var combinedSize = 1</span>
<span class="fc" id="L186">                    val prevFather: MutableSet&lt;Int&gt; = HashSet()</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">                    for (k in 0..3) {</span>
<span class="fc" id="L188">                        val newI = i + dx[k]</span>
<span class="fc" id="L189">                        val newJ = j + dy[k]</span>
<span class="fc" id="L190">                        val newId = newI * cols + newJ</span>
<span class="pc bpc" id="L191" title="1 of 4 branches missed.">                        if (isValid(rows, cols, newI, newJ) &amp;&amp; grid[newI][newJ] == 1) {</span>
<span class="fc" id="L192">                            val currFather = find(father, newId)</span>
<span class="fc bfc" id="L193" title="All 4 branches covered.">                            if (prevFather.isEmpty() || !prevFather.contains(currFather)) {</span>
<span class="fc" id="L194">                                combinedSize += size[currFather]</span>
<span class="fc" id="L195">                                prevFather.add(currFather)</span>
                            }
                        }
                    }
<span class="fc" id="L199">                    max = max(max, combinedSize)</span>
                }
            }
        }
<span class="fc" id="L203">        return max</span>
    }

    private fun scanGrid(
        rows: Int,
        cols: Int,
        grid: Array&lt;IntArray&gt;,
        dx: IntArray,
        dy: IntArray,
        father: IntArray,
        size: IntArray,
    ) {
        // scan grid, update father array and size array
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (i in 0 until rows) {</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            for (j in 0 until cols) {</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">                if (grid[i][j] == 1) {</span>
<span class="fc" id="L219">                    val id = i * cols + j</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                    for (k in 0..3) {</span>
<span class="fc" id="L221">                        val newI = i + dx[k]</span>
<span class="fc" id="L222">                        val newJ = j + dy[k]</span>
<span class="fc" id="L223">                        val newId = newI * cols + newJ</span>
<span class="fc bfc" id="L224" title="All 4 branches covered.">                        if (isValid(rows, cols, newI, newJ) &amp;&amp; grid[newI][newJ] == 1) {</span>
<span class="fc" id="L225">                            union(father, size, id, newId)</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L231">    }</span>

    private fun find(father: IntArray, id: Int): Int {
<span class="fc bfc" id="L234" title="All 2 branches covered.">        return if (father[id] == id) {</span>
<span class="fc" id="L235">            id</span>
        } else {
<span class="fc" id="L237">            find(father, father[id]).also { father[id] = it }</span>
        }
    }

    private fun union(father: IntArray, size: IntArray, id1: Int, id2: Int) {
<span class="fc" id="L242">        val fa1 = find(father, id1)</span>
<span class="fc" id="L243">        val fa2 = find(father, id2)</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (fa1 != fa2) {</span>
<span class="fc" id="L245">            father[fa1] = fa2</span>
<span class="fc" id="L246">            size[fa2] += size[fa1]</span>
        }
<span class="fc" id="L248">    }</span>

    private fun isValid(rows: Int, cols: Int, i: Int, j: Int): Boolean {
<span class="fc bfc" id="L251" title="All 10 branches covered.">        return i in 0 until rows &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; cols</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>