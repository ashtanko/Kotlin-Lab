<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SortedListToBST.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kotlab</a> &gt; <a href="index.source.html" class="el_package">dev.shtanko.algorithms.leetcode</a> &gt; <span class="el_source">SortedListToBST.kt</span></div><h1>SortedListToBST.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 Oleksii Shtanko
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.shtanko.algorithms.leetcode

/**
 *
 */
fun interface SortedListToBST {
    operator fun invoke(head: ListNode?): TreeNode?
}

/**
 * Approach 1: Recursion
 */
<span class="fc" id="L29">class SortedListToBSTRecursion : SortedListToBST {</span>

    override operator fun invoke(head: ListNode?): TreeNode? {
        // If the head doesn't exist, then the linked list is empty
<span class="fc bfc" id="L33" title="All 2 branches covered.">        if (head == null) {</span>
<span class="fc" id="L34">            return null</span>
        }

        // Find the middle element for the list.

        // Find the middle element for the list.
<span class="fc" id="L40">        val mid = findMiddleElement(head)</span>

        // The mid becomes the root of the BST.
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">        val node = TreeNode(mid?.value!!)</span>

        // Base case when there is just one element in the linked list

        // Base case when there is just one element in the linked list
<span class="fc bfc" id="L48" title="All 2 branches covered.">        if (head === mid) {</span>
<span class="fc" id="L49">            return node</span>
        }

        // Recursively form balanced BSTs using the left and right halves of the original list.

        // Recursively form balanced BSTs using the left and right halves of the original list.
<span class="fc" id="L55">        node.left = this.invoke(head)</span>
<span class="fc" id="L56">        node.right = this.invoke(mid.next)</span>
<span class="fc" id="L57">        return node</span>
    }

    private fun findMiddleElement(head: ListNode): ListNode? {
        // The pointer used to disconnect the left half from the mid-node.
<span class="fc" id="L62">        var prevPtr: ListNode? = null</span>
<span class="fc" id="L63">        var slowPtr: ListNode? = head</span>
<span class="fc" id="L64">        var fastPtr: ListNode? = head</span>

        // Iterate until fastPr doesn't reach the end of the linked list.
<span class="fc bfc" id="L67" title="All 4 branches covered.">        while (fastPtr?.next != null) {</span>
<span class="fc" id="L68">            prevPtr = slowPtr</span>
<span class="fc" id="L69">            slowPtr = slowPtr!!.next</span>
<span class="fc" id="L70">            fastPtr = fastPtr.next!!.next</span>
        }

        // Handling the case when slowPtr was equal to head.
<span class="fc bfc" id="L74" title="All 2 branches covered.">        if (prevPtr != null) {</span>
<span class="fc" id="L75">            prevPtr.next = null</span>
        }
<span class="fc" id="L77">        return slowPtr</span>
    }
}

/**
 * Approach 2: Recursion + Conversion to Array
 */
<span class="fc" id="L84">class SortedListToBSTArray : SortedListToBST {</span>
<span class="fc" id="L85">    private val values: MutableList&lt;Int&gt; = ArrayList()</span>

    override operator fun invoke(head: ListNode?): TreeNode {
<span class="fc" id="L88">        this.mapListToValues(head)</span>
        // Convert the array to
<span class="fc" id="L90">        return convertListToBST(0, this.values.size - 1)!!</span>
    }

    private fun mapListToValues(head: ListNode?) {
<span class="fc" id="L94">        var node: ListNode? = head</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">        while (node != null) {</span>
<span class="fc" id="L96">            values.add(node.value)</span>
<span class="fc" id="L97">            node = node.next</span>
        }
<span class="fc" id="L99">    }</span>

    private fun convertListToBST(left: Int, right: Int): TreeNode? {
        // Invalid case
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (left &gt; right) {</span>
<span class="fc" id="L104">            return null</span>
        }

        // Middle element forms the root.
<span class="fc" id="L108">        val mid = (left + right) / 2</span>
<span class="fc" id="L109">        val node = TreeNode(values[mid])</span>

        // Base case for when there is only one element left in the array
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (left == right) {</span>
<span class="fc" id="L113">            return node</span>
        }

        // Recursively form BST on the two halves
<span class="fc" id="L117">        node.left = convertListToBST(left, mid - 1)</span>
<span class="fc" id="L118">        node.right = convertListToBST(mid + 1, right)</span>
<span class="fc" id="L119">        return node</span>
    }
}

/**
 * Approach 3: Inorder Simulation
 */
<span class="fc" id="L126">class SortedListToBSTInorder : SortedListToBST {</span>

    private var head: ListNode? = null

    override operator fun invoke(head: ListNode?): TreeNode? {
        // Get the size of the linked list first
<span class="fc" id="L132">        val size = findSize(head)</span>
<span class="fc" id="L133">        this.head = head</span>
        // Form the BST now that we know the size
<span class="fc" id="L135">        return convertListToBST(0, size - 1)</span>
    }

    private fun convertListToBST(l: Int, r: Int): TreeNode? {
        // Invalid case
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (l &gt; r) {</span>
<span class="fc" id="L141">            return null</span>
        }
<span class="fc" id="L143">        val mid = (l + r) / 2</span>

        // First step of simulated inorder traversal. Recursively form
        // the left half
<span class="fc" id="L147">        val left = convertListToBST(l, mid - 1)</span>

        // Once left half is traversed, process the current node
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        val node = TreeNode(head?.value!!)</span>
<span class="fc" id="L151">        node.left = left</span>

        // Maintain the invariance mentioned in the algorithm
<span class="fc" id="L154">        head = head!!.next</span>

        // Recurse on the right hand side and form BST out of them
<span class="fc" id="L157">        node.right = convertListToBST(mid + 1, r)</span>
<span class="fc" id="L158">        return node</span>
    }

    private fun findSize(head: ListNode?): Int {
<span class="fc" id="L162">        var ptr: ListNode? = head</span>
<span class="fc" id="L163">        var c = 0</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        while (ptr != null) {</span>
<span class="fc" id="L165">            ptr = ptr.next</span>
<span class="fc" id="L166">            c += 1</span>
        }
<span class="fc" id="L168">        return c</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>