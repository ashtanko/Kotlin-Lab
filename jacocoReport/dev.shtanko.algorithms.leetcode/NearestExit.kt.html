<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NearestExit.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kotlab</a> &gt; <a href="index.source.html" class="el_package">dev.shtanko.algorithms.leetcode</a> &gt; <span class="el_source">NearestExit.kt</span></div><h1>NearestExit.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2022 Oleksii Shtanko
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.shtanko.algorithms.leetcode

import java.util.LinkedList
import java.util.Queue

/**
 * 1926. Nearest Exit from Entrance in Maze
 * @see &lt;a href=&quot;https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/&quot;&gt;leetcode page&lt;/a&gt;
 */
fun interface NearestExit {
    operator fun invoke(maze: Array&lt;CharArray&gt;, entrance: IntArray): Int
}

/**
 * Approach 1: Breadth First Search (BFS)
 */
<span class="fc" id="L33">class NearestExitBFS : NearestExit {</span>
    override operator fun invoke(maze: Array&lt;CharArray&gt;, entrance: IntArray): Int {
<span class="fc" id="L35">        val rows: Int = maze.size</span>
<span class="fc" id="L36">        val cols: Int = maze[0].size</span>
<span class="fc" id="L37">        val dirs = arrayOf(intArrayOf(1, 0), intArrayOf(-1, 0), intArrayOf(0, 1), intArrayOf(0, -1))</span>

        // Mark the entrance as visited since it's not an exit.
<span class="fc" id="L40">        val startRow = entrance[0]</span>
<span class="fc" id="L41">        val startCol = entrance[1]</span>
<span class="fc" id="L42">        maze[startRow][startCol] = '+'</span>

        // Start BFS from the entrance, and use a queue `queue` to store all
        // the cells to be visited.
<span class="fc" id="L46">        val queue: Queue&lt;IntArray&gt; = LinkedList()</span>
<span class="fc" id="L47">        queue.offer(intArrayOf(startRow, startCol, 0))</span>

<span class="fc bfc" id="L49" title="All 2 branches covered.">        while (!queue.isEmpty()) {</span>
<span class="fc" id="L50">            val currState: IntArray = queue.poll()</span>
<span class="fc" id="L51">            val currRow = currState[0]</span>
<span class="fc" id="L52">            val currCol = currState[1]</span>
<span class="fc" id="L53">            val currDistance = currState[2]</span>

            // For the current cell, check its four neighbor cells.
<span class="fc bfc" id="L56" title="All 2 branches covered.">            for (dir in dirs) {</span>
<span class="fc" id="L57">                val nextRow = currRow + dir[0]</span>
<span class="fc" id="L58">                val nextCol = currCol + dir[1]</span>

                // If there exists an unvisited empty neighbor:
<span class="pc bpc" id="L61" title="1 of 12 branches missed.">                if (nextRow in 0 until rows &amp;&amp; 0 &lt;= nextCol &amp;&amp; nextCol &lt; cols &amp;&amp; maze[nextRow][nextCol] == '.') {</span>
                    // If this empty cell is an exit, return distance + 1.
<span class="pc bpc" id="L63" title="2 of 8 branches missed.">                    if (nextRow == 0 || nextRow == rows - 1 || nextCol == 0 || nextCol == cols - 1) {</span>
<span class="fc" id="L64">                        return currDistance + 1</span>
                    }

                    // Otherwise, add this cell to 'queue' and mark it as visited.
<span class="fc" id="L68">                    maze[nextRow][nextCol] = '+'</span>
<span class="fc" id="L69">                    queue.offer(intArrayOf(nextRow, nextCol, currDistance + 1))</span>
                }
            }
        }

        // If we finish iterating without finding an exit, return -1.
<span class="fc" id="L75">        return -1</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>