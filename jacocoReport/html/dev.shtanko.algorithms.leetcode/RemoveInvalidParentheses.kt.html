<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RemoveInvalidParentheses.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kotlab</a> &gt; <a href="index.source.html" class="el_package">dev.shtanko.algorithms.leetcode</a> &gt; <span class="el_source">RemoveInvalidParentheses.kt</span></div><h1>RemoveInvalidParentheses.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2022 Oleksii Shtanko
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.shtanko.algorithms.leetcode

/**
 * 301. Remove Invalid Parentheses
 * @see &lt;a href=&quot;https://leetcode.com/problems/remove-invalid-parentheses/&quot;&gt;Source&lt;/a&gt;
 */
fun interface RemoveInvalidParentheses {
    operator fun invoke(s: String): List&lt;String&gt;
}

/**
 * Approach 1: Backtracking
 */
<span class="fc" id="L30">class RemoveInvalidParenthesesBacktracking : RemoveInvalidParentheses {</span>

<span class="fc" id="L32">    private val validExpressions: MutableSet&lt;String&gt; = HashSet()</span>
<span class="fc" id="L33">    private var minimumRemoved = Int.MAX_VALUE</span>
<span class="fc" id="L34">    private val expression = StringBuilder()</span>

    override operator fun invoke(s: String): List&lt;String&gt; {
<span class="fc" id="L37">        recurse(s, 0, 0, 0, 0)</span>
<span class="fc" id="L38">        return validExpressions.toList()</span>
    }

    private fun recurse(
        s: String,
        index: Int,
        leftCount: Int,
        rightCount: Int,
        removedCount: Int,
    ) {
        // If we have reached the end of string.
<span class="fc bfc" id="L49" title="All 2 branches covered.">        if (index == s.length) {</span>
            // If the current expression is valid.
<span class="fc bfc" id="L51" title="All 2 branches covered.">            if (leftCount == rightCount) {</span>
                // If the current count of removed parentheses is &lt;= the current minimum count
<span class="fc bfc" id="L53" title="All 2 branches covered.">                if (removedCount &lt;= minimumRemoved) {</span>
                    // Convert StringBuilder to a String. This is an expensive operation.
                    // So we only perform this when needed.
<span class="fc" id="L56">                    val possibleAnswer = expression.toString()</span>

                    // If the current count beats the overall minimum we have till now
<span class="fc bfc" id="L59" title="All 2 branches covered.">                    if (removedCount &lt; minimumRemoved) {</span>
<span class="fc" id="L60">                        validExpressions.clear()</span>
<span class="fc" id="L61">                        minimumRemoved = removedCount</span>
                    }
<span class="fc" id="L63">                    validExpressions.add(possibleAnswer)</span>
                }
            }
        } else {
<span class="fc" id="L67">            val currentCharacter = s[index]</span>
<span class="fc" id="L68">            val length = expression.length</span>

            // If the current character is neither an opening bracket nor a closing one,
            // simply recurse further by adding it to the expression StringBuilder
<span class="fc bfc" id="L72" title="All 4 branches covered.">            if (currentCharacter != '(' &amp;&amp; currentCharacter != ')') {</span>
<span class="fc" id="L73">                expression.append(currentCharacter)</span>
<span class="fc" id="L74">                recurse(s, index + 1, leftCount, rightCount, removedCount)</span>
<span class="fc" id="L75">                expression.deleteCharAt(length)</span>
            } else {
                // Recursion where we delete the current character and move forward
<span class="fc" id="L78">                recurse(s, index + 1, leftCount, rightCount, removedCount + 1)</span>
<span class="fc" id="L79">                expression.append(currentCharacter)</span>

                // If it's an opening parenthesis, consider it and recurse
<span class="fc bfc" id="L82" title="All 2 branches covered.">                if (currentCharacter == '(') {</span>
<span class="fc" id="L83">                    recurse(s, index + 1, leftCount + 1, rightCount, removedCount)</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">                } else if (rightCount &lt; leftCount) {</span>
                    // For a closing parenthesis, only recurse if right &lt; left
<span class="fc" id="L86">                    recurse(s, index + 1, leftCount, rightCount + 1, removedCount)</span>
                }

                // Undoing the append operation for other recursions.
<span class="fc" id="L90">                expression.deleteCharAt(length)</span>
            }
        }
<span class="fc" id="L93">    }</span>
}

/**
 * Approach 2: Limited Backtracking!
 */
<span class="fc" id="L99">class RemoveInvalidParenthesesLBacktracking : RemoveInvalidParentheses {</span>

<span class="fc" id="L101">    private val validExpressions: MutableSet&lt;String&gt; = HashSet()</span>

    override operator fun invoke(s: String): List&lt;String&gt; {
<span class="fc" id="L104">        var left = 0</span>
<span class="fc" id="L105">        var right = 0</span>

        // First, we find out the number of misplaced left and right parentheses.
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (i in s.indices) {</span>
            // Simply record the left one.
<span class="fc bfc" id="L110" title="All 2 branches covered.">            if (s[i] == '(') {</span>
<span class="fc" id="L111">                left++</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            } else if (s[i] == ')') {</span>
                // If we don't have a matching left, then this is a misplaced right, record it.
<span class="fc bfc" id="L114" title="All 2 branches covered.">                right = if (left == 0) right + 1 else right</span>

                // Decrement count of left parentheses because we have found a right
                // which CAN be a matching one for a left.
<span class="fc bfc" id="L118" title="All 2 branches covered.">                left = if (left &gt; 0) left - 1 else left</span>
            }
        }

<span class="fc" id="L122">        recurse(s, 0, 0, 0, left, right, StringBuilder())</span>
<span class="fc" id="L123">        return validExpressions.toList()</span>
    }

    private fun recurse(
        s: String,
        index: Int,
        leftCount: Int,
        rightCount: Int,
        leftRem: Int,
        rightRem: Int,
        expression: StringBuilder,
    ) {
        // If we reached the end of the string, just check if the resulting expression is
        // valid or not and also if we have removed the total number of left and right
        // parentheses that we should have removed.
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (index == s.length) {</span>
<span class="pc bpc" id="L139" title="1 of 4 branches missed.">            if (leftRem == 0 &amp;&amp; rightRem == 0) {</span>
<span class="fc" id="L140">                validExpressions.add(expression.toString())</span>
            }
        } else {
<span class="fc" id="L143">            val character = s[index]</span>
<span class="fc" id="L144">            val length = expression.length</span>

            // The discard case. Note that here we have our pruning condition.
            // We don't recurse if the remaining count for that parenthesis is == 0.
<span class="fc bfc" id="L148" title="All 8 branches covered.">            if (character == '(' &amp;&amp; leftRem &gt; 0 || character == ')' &amp;&amp; rightRem &gt; 0) {</span>
<span class="fc" id="L149">                recurse(</span>
<span class="fc" id="L150">                    s,</span>
<span class="fc" id="L151">                    index + 1,</span>
<span class="fc" id="L152">                    leftCount,</span>
<span class="fc" id="L153">                    rightCount,</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">                    leftRem - if (character == '(') 1 else 0,</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">                    rightRem - if (character == ')') 1 else 0,</span>
<span class="fc" id="L156">                    expression,</span>
                )
            }
<span class="fc" id="L159">            expression.append(character)</span>

            // Simply recurse one step further if the current character is not a parenthesis.
<span class="fc bfc" id="L162" title="All 4 branches covered.">            if (character != '(' &amp;&amp; character != ')') {</span>
<span class="fc" id="L163">                recurse(s, index + 1, leftCount, rightCount, leftRem, rightRem, expression)</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            } else if (character == '(') {</span>
                // Consider an opening bracket.
<span class="fc" id="L166">                recurse(s, index + 1, leftCount + 1, rightCount, leftRem, rightRem, expression)</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            } else if (rightCount &lt; leftCount) {</span>
                // Consider a closing bracket.
<span class="fc" id="L169">                recurse(s, index + 1, leftCount, rightCount + 1, leftRem, rightRem, expression)</span>
            }

            // Delete for backtracking.
<span class="fc" id="L173">            expression.deleteCharAt(length)</span>
        }
<span class="fc" id="L175">    }</span>
}

<span class="fc" id="L178">class RemoveInvalidParenthesesFast : RemoveInvalidParentheses {</span>
    override operator fun invoke(s: String): List&lt;String&gt; {
<span class="fc" id="L180">        val ans: MutableList&lt;String&gt; = ArrayList()</span>
<span class="fc" id="L181">        remove(s, ans, 0, 0, charArrayOf('(', ')'))</span>
<span class="fc" id="L182">        return ans</span>
    }

    private fun remove(s: String, ans: MutableList&lt;String&gt;, lastI: Int, lastJ: Int, par: CharArray) {
<span class="fc" id="L186">        var stack = 0</span>
<span class="fc" id="L187">        var i = lastI</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        while (i &lt; s.length) {</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">            if (s[i] == par[0]) stack++</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">            if (s[i] == par[1]) stack--</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (stack &gt;= 0) {</span>
<span class="fc" id="L192">                ++i</span>
<span class="fc" id="L193">                continue</span>
            }
<span class="pc bpc" id="L195" title="1 of 10 branches missed.">            for (j in lastJ..i) if (s[j] == par[1] &amp;&amp; (j == lastJ || s[j - 1] != par[1])) {</span>
<span class="fc" id="L196">                remove(</span>
<span class="fc" id="L197">                    s.substring(</span>
<span class="fc" id="L198">                        0,</span>
                        j,
<span class="fc" id="L200">                    ) + s.substring(j + 1, s.length),</span>
<span class="fc" id="L201">                    ans,</span>
<span class="fc" id="L202">                    i,</span>
<span class="fc" id="L203">                    j,</span>
<span class="fc" id="L204">                    par,</span>
                )
            }
<span class="fc" id="L207">            ++i</span>
<span class="fc" id="L208">            return</span>
        }
<span class="fc" id="L210">        val reversed = StringBuilder(s).reverse().toString()</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (par[0] == '(') {</span>
            // finished left to right
<span class="fc" id="L213">            remove(reversed, ans, 0, 0, charArrayOf(')', '('))</span>
        } else {
            // finished right to left
<span class="fc" id="L216">            ans.add(reversed)</span>
        }
<span class="fc" id="L218">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>