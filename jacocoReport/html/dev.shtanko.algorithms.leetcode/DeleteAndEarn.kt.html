<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DeleteAndEarn.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kotlab</a> &gt; <a href="index.source.html" class="el_package">dev.shtanko.algorithms.leetcode</a> &gt; <span class="el_source">DeleteAndEarn.kt</span></div><h1>DeleteAndEarn.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2022 Oleksii Shtanko
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.shtanko.algorithms.leetcode

import kotlin.math.ln
import kotlin.math.max

/**
 * 740. Delete and Earn
 * @see &lt;a href=&quot;https://leetcode.com/problems/delete-and-earn/&quot;&gt;leetcode page&lt;/a&gt;
 */
fun interface DeleteAndEarn {
    operator fun invoke(nums: IntArray): Int
}

/**
 * Approach 1: Top-Down Dynamic Programming
 */
<span class="fc" id="L33">class DeleteAndEarnTopDown : DeleteAndEarn {</span>

<span class="fc" id="L35">    private val points = HashMap&lt;Int, Int&gt;()</span>
<span class="fc" id="L36">    private val cache = HashMap&lt;Int, Int&gt;()</span>

    override operator fun invoke(nums: IntArray): Int {
<span class="fc" id="L39">        var maxNumber = 0</span>

        // Precompute how many points we gain from taking an element
<span class="fc bfc" id="L42" title="All 2 branches covered.">        for (num in nums) {</span>
<span class="fc" id="L43">            points[num] = points.getOrDefault(num, 0) + num</span>
<span class="fc" id="L44">            maxNumber = max(maxNumber, num)</span>
        }

<span class="fc" id="L47">        return maxPoints(maxNumber)</span>
    }

    private fun maxPoints(num: Int): Int {
        // Check for base cases
<span class="fc bfc" id="L52" title="All 2 branches covered.">        if (num == 0) {</span>
<span class="fc" id="L53">            return 0</span>
        }
<span class="fc bfc" id="L55" title="All 2 branches covered.">        if (num == 1) {</span>
<span class="fc" id="L56">            return points.getOrDefault(1, 0)</span>
        }
<span class="fc bfc" id="L58" title="All 2 branches covered.">        if (cache.containsKey(num)) {</span>
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">            return cache[num] ?: -1</span>
        }

        // Apply recurrence relation
<span class="fc" id="L63">        val gain = points.getOrDefault(num, 0)</span>
<span class="fc" id="L64">        cache[num] = max(maxPoints(num - 1), maxPoints(num - 2) + gain)</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">        return cache[num] ?: -1</span>
    }
}

/**
 * Approach 2: Bottom-Up Dynamic Programming
 */
<span class="fc" id="L72">class DeleteAndEarnBottomUp : DeleteAndEarn {</span>
    override operator fun invoke(nums: IntArray): Int {
<span class="fc bfc" id="L74" title="All 4 branches covered.">        if (nums.isEmpty()) return 0</span>
<span class="fc" id="L75">        val points = HashMap&lt;Int, Int&gt;()</span>
<span class="fc" id="L76">        var maxNumber = 0</span>

        // Precompute how many points we gain from taking an element
<span class="fc bfc" id="L79" title="All 2 branches covered.">        for (num in nums) {</span>
<span class="fc" id="L80">            points[num] = points.getOrDefault(num, 0) + num</span>
<span class="fc" id="L81">            maxNumber = max(maxNumber, num)</span>
        }

        // Declare our array along with base cases
<span class="fc" id="L85">        val maxPoints = IntArray(maxNumber + 1)</span>
<span class="fc" id="L86">        maxPoints[1] = points.getOrDefault(1, 0)</span>

<span class="fc bfc" id="L88" title="All 2 branches covered.">        for (num in 2 until maxPoints.size) {</span>
            // Apply recurrence relation
<span class="fc" id="L90">            val gain = points.getOrDefault(num, 0)</span>
<span class="fc" id="L91">            maxPoints[num] = max(maxPoints[num - 1], maxPoints[num - 2] + gain)</span>
        }

<span class="fc" id="L94">        return maxPoints[maxNumber]</span>
    }
}

/**
 * Approach 3: Space Optimized Bottom-Up Dynamic Programming
 */
<span class="fc" id="L101">class DeleteAndEarnBottomUpOpt : DeleteAndEarn {</span>
    override operator fun invoke(nums: IntArray): Int {
<span class="fc" id="L103">        var maxNumber = 0</span>
<span class="fc" id="L104">        val points = HashMap&lt;Int, Int&gt;()</span>

        // Precompute how many points we gain from taking an element
<span class="fc bfc" id="L107" title="All 2 branches covered.">        for (num in nums) {</span>
<span class="fc" id="L108">            points[num] = points.getOrDefault(num, 0) + num</span>
<span class="fc" id="L109">            maxNumber = max(maxNumber, num)</span>
        }

        // Base cases
<span class="fc" id="L113">        var twoBack = 0</span>
<span class="fc" id="L114">        var oneBack = points.getOrDefault(1, 0)</span>

<span class="fc bfc" id="L116" title="All 4 branches covered.">        for (num in 2..maxNumber) {</span>
<span class="fc" id="L117">            val temp = oneBack</span>
<span class="fc" id="L118">            oneBack = max(oneBack, twoBack + points.getOrDefault(num, 0))</span>
<span class="fc" id="L119">            twoBack = temp</span>
        }

<span class="fc" id="L122">        return oneBack</span>
    }
}

/**
 * Approach 4: Iterate Over Elements
 */
<span class="fc" id="L129">class DeleteAndEarnIterative : DeleteAndEarn {</span>
    override operator fun invoke(nums: IntArray): Int {
<span class="fc" id="L131">        val points = HashMap&lt;Int, Int&gt;()</span>

        // Precompute how many points we gain from taking an element
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (num in nums) {</span>
<span class="fc" id="L135">            points[num] = points.getOrDefault(num, 0) + num</span>
        }

<span class="fc" id="L138">        val elements: List&lt;Int&gt; = ArrayList(points.keys).sorted()</span>

        // Base cases
<span class="fc" id="L141">        var twoBack = 0</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        var oneBack = points[elements.firstOrNull()] ?: 0</span>

<span class="fc bfc" id="L144" title="All 2 branches covered.">        for (i in 1 until elements.size) {</span>
<span class="fc" id="L145">            val currentElement = elements[i]</span>
<span class="fc" id="L146">            val temp = oneBack</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">            if (currentElement == elements[i - 1] + 1) {</span>
                // The 2 elements are adjacent, cannot take both - apply normal recurrence
<span class="fc" id="L149">                oneBack = max(oneBack, twoBack + points[currentElement]!!)</span>
            } else {
                // Otherwise, we don't need to worry about adjacent deletions
<span class="nc bnc" id="L152" title="All 2 branches missed.">                oneBack += points[currentElement] ?: 0</span>
            }
<span class="fc" id="L154">            twoBack = temp</span>
        }

<span class="fc" id="L157">        return oneBack</span>
    }
}

<span class="fc" id="L161">class DeleteAndEarnBest : DeleteAndEarn {</span>
    override operator fun invoke(nums: IntArray): Int {
<span class="fc" id="L163">        var maxNumber = 0</span>
<span class="fc" id="L164">        val points = HashMap&lt;Int, Int&gt;()</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (num in nums) {</span>
<span class="fc" id="L167">            points[num] = points.getOrDefault(num, 0) + num</span>
<span class="fc" id="L168">            maxNumber = max(maxNumber, num)</span>
        }

<span class="fc" id="L171">        var twoBack = 0</span>
        var oneBack: Int
<span class="fc" id="L173">        val n = points.size</span>

<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (maxNumber &lt; n + n * ln(n.toDouble()) / ln(2.0)) {</span>
<span class="fc" id="L176">            oneBack = points.getOrDefault(1, 0)</span>
<span class="pc bpc" id="L177" title="1 of 4 branches missed.">            for (num in 2..maxNumber) {</span>
<span class="fc" id="L178">                val temp = oneBack</span>
<span class="fc" id="L179">                oneBack = max(oneBack, twoBack + points.getOrDefault(num, 0))</span>
<span class="fc" id="L180">                twoBack = temp</span>
            }
        } else {
<span class="fc" id="L183">            val elements: List&lt;Int&gt; = ArrayList(points.keys).sorted()</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">            oneBack = points[elements.firstOrNull()] ?: 0</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            for (i in 1 until elements.size) {</span>
<span class="nc" id="L186">                val currentElement = elements[i]</span>
<span class="nc" id="L187">                val temp = oneBack</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                if (currentElement == elements[i - 1] + 1) {</span>
<span class="nc" id="L189">                    oneBack = max(oneBack, twoBack + points[currentElement]!!)</span>
                } else {
<span class="nc" id="L191">                    oneBack += points[currentElement]!!</span>
                }
<span class="nc" id="L193">                twoBack = temp</span>
            }
        }

<span class="fc" id="L197">        return oneBack</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>