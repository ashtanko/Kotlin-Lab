<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CatAndMouse.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kotlab</a> &gt; <a href="index.source.html" class="el_package">dev.shtanko.algorithms.leetcode</a> &gt; <span class="el_source">CatAndMouse.kt</span></div><h1>CatAndMouse.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 Oleksii Shtanko
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.shtanko.algorithms.leetcode

import java.util.LinkedList
import java.util.Queue

/**
 * 913. Cat and Mouse
 * @see &lt;a href=&quot;https://leetcode.com/problems/cat-and-mouse/&quot;&gt;Source&lt;/a&gt;
 */
fun interface CatAndMouse {
    fun catMouseGame(graph: Array&lt;IntArray&gt;): Int
}

<span class="fc" id="L30">class CatAndMouseMinimax : CatAndMouse {</span>

    override fun catMouseGame(graph: Array&lt;IntArray&gt;): Int {
<span class="fc" id="L33">        val n: Int = graph.size</span>
<span class="fc bfc" id="L34" title="All 4 branches covered.">        val status = Array(SIZE) { Array(SIZE) { IntArray(CHUNK_SIZE) } }</span>
<span class="fc bfc" id="L35" title="All 4 branches covered.">        val childrenNum = Array(SIZE) { Array(SIZE) { IntArray(CHUNK_SIZE) } }</span>

        // mouse location
<span class="fc bfc" id="L38" title="All 2 branches covered.">        for (m in 0 until n) {</span>
            // cat location
<span class="fc bfc" id="L40" title="All 2 branches covered.">            for (c in 0 until n) {</span>
<span class="fc" id="L41">                childrenNum[m][c][MOUSE_TURN] = graph[m].size</span>
<span class="fc" id="L42">                childrenNum[m][c][CAT_TURN] = graph[c].size</span>
<span class="fc bfc" id="L43" title="All 2 branches covered.">                for (x in graph[c]) {</span>
                    // The cat can not stay at the hole (position 0).
<span class="fc bfc" id="L45" title="All 2 branches covered.">                    if (x == 0) {</span>
<span class="fc" id="L46">                        childrenNum[m][c][CAT_TURN]--</span>
<span class="fc" id="L47">                        break</span>
                    }
                }
            }
        }

        // enqueued : all nodes that we know who wins in the end. Nodes with DRAW status is not in this queue.
<span class="fc" id="L54">        val queue = enqueuedAllNodes(n, status)</span>

        // percolate nodes that we know who wins in the end
<span class="fc bfc" id="L57" title="All 2 branches covered.">        while (!queue.isEmpty()) {</span>
<span class="fc" id="L58">            val node: IntArray = queue.remove()</span>
<span class="fc" id="L59">            val m = node[0]</span>
<span class="fc" id="L60">            val c = node[1]</span>
<span class="fc" id="L61">            val t = node[2]</span>
<span class="fc" id="L62">            val s = node[3] // mouse_location, cat_location, turn, status</span>
            // for every parent of this node (m, c, t) :
<span class="fc bfc" id="L64" title="All 2 branches covered.">            for (parent in parents(graph, m, c, t)) {</span>
<span class="fc" id="L65">                val m2 = parent[0]</span>
<span class="fc" id="L66">                val c2 = parent[1]</span>
<span class="fc" id="L67">                val t2 = parent[2] // mouse_location2, cat_location2, turn2</span>
                // if we do not know who wins in this parent node
<span class="fc bfc" id="L69" title="All 2 branches covered.">                if (status[m2][c2][t2] == DRAW) {</span>
<span class="fc bfc" id="L70" title="All 8 branches covered.">                    if (t2 == MOUSE_TURN &amp;&amp; s == MOUSE_WIN || t2 == CAT_TURN &amp;&amp; s == CAT_WIN) {</span>
                        // if the parent can make a winning move (mouse to MOUSE_WIN, or cat to CAT_WIN)
<span class="fc" id="L72">                        status[m2][c2][t2] = s</span>
<span class="fc" id="L73">                        queue.add(intArrayOf(m2, c2, t2, s))</span>
                    } else {
                        // else, this parent has neutral children_num[parent]--.
                        // Enqueue if all children of this parent are colored as losing moves.
<span class="fc" id="L77">                        childrenNum[m2][c2][t2]--</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">                        if (childrenNum[m2][c2][t2] == 0) {</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">                            status[m2][c2][t2] = if (t2 == MOUSE_TURN) CAT_WIN else MOUSE_WIN</span>
<span class="fc" id="L80">                            queue.add(intArrayOf(m2, c2, t2, status[m2][c2][t2]))</span>
                        }
                    }
                }
            }
        }

<span class="fc" id="L87">        return status[1][2][MOUSE_TURN] // The mouse is at location 1. The cat is at location 2. The mouse moves first.</span>
    }

    private fun enqueuedAllNodes(n: Int, status: Array&lt;Array&lt;IntArray&gt;&gt;): Queue&lt;IntArray&gt; {
        // enqueued : all nodes that we know who wins in the end. Nodes with DRAW status is not in this queue.
<span class="fc" id="L92">        val queue: Queue&lt;IntArray&gt; = LinkedList()</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        for (i in 0 until n) {</span>
            // turn
<span class="fc bfc" id="L95" title="All 2 branches covered.">            for (t in 1..2) {</span>
<span class="fc" id="L96">                status[0][i][t] = MOUSE_WIN // The mouse wins if it is at the hole (position 0).</span>
<span class="fc" id="L97">                queue.add(intArrayOf(0, i, t, MOUSE_WIN))</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">                if (i &gt; 0) {</span>
<span class="fc" id="L99">                    status[i][i][t] = CAT_WIN // The cat wins if mouse and cat are at the same location.</span>
<span class="fc" id="L100">                    queue.add(intArrayOf(i, i, t, CAT_WIN))</span>
                }
            }
        }
<span class="fc" id="L104">        return queue</span>
    }

    // What nodes could play their turn to arrive at node (m, c, t) ?
    private fun parents(graph: Array&lt;IntArray&gt;, m: Int, c: Int, t: Int): List&lt;IntArray&gt; {
<span class="fc" id="L109">        val ans: MutableList&lt;IntArray&gt; = ArrayList()</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (t == CAT_TURN) {</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            for (m2 in graph[m]) {</span>
<span class="fc" id="L112">                ans.add(intArrayOf(m2, c, MOUSE_TURN))</span>
            }
        } else {
<span class="fc bfc" id="L115" title="All 2 branches covered.">            for (c2 in graph[c]) {</span>
                // The cat can not stay at the hole (position 0).
<span class="fc bfc" id="L117" title="All 2 branches covered.">                if (c2 &gt; 0) {</span>
<span class="fc" id="L118">                    ans.add(intArrayOf(m, c2, CAT_TURN))</span>
                }
            }
        }
<span class="fc" id="L122">        return ans</span>
    }

    companion object {
        private const val SIZE = 50
        private const val CHUNK_SIZE = 3
        private const val DRAW = 0
        private const val MOUSE_WIN = 1
        private const val CAT_WIN = 2
        private const val MOUSE_TURN = 1
        private const val CAT_TURN = 2
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>