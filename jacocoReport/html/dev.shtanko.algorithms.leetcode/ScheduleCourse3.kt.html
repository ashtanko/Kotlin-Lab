<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ScheduleCourse3.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kotlab</a> &gt; <a href="index.source.html" class="el_package">dev.shtanko.algorithms.leetcode</a> &gt; <span class="el_source">ScheduleCourse3.kt</span></div><h1>ScheduleCourse3.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 Oleksii Shtanko
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.shtanko.algorithms.leetcode

import java.util.PriorityQueue
import kotlin.math.max

/**
 * 630. Course Schedule III
 * @see &lt;a href=&quot;https://leetcode.com/problems/course-schedule-iii/&quot;&gt;Source&lt;/a&gt;
 */
fun interface ScheduleCourse3 {
    operator fun invoke(courses: Array&lt;IntArray&gt;): Int
}

/**
 * Approach 2: Recursion with Memoization
 */
<span class="fc" id="L33">class ScheduleCourse3Recursion : ScheduleCourse3 {</span>
    override operator fun invoke(courses: Array&lt;IntArray&gt;): Int {
<span class="fc" id="L35">        courses.sortWith { a, b -&gt; a[1] - b[1] }</span>
<span class="fc bfc" id="L36" title="All 2 branches covered.">        val memo = Array(courses.size) {</span>
            arrayOfNulls&lt;Int&gt;(
<span class="fc" id="L38">                courses[courses.size - 1][1] + 1,</span>
            )
        }
<span class="fc" id="L41">        return schedule(courses, 0, 0, memo)</span>
    }

    private fun schedule(courses: Array&lt;IntArray&gt;, i: Int, time: Int, memo: Array&lt;Array&lt;Int?&gt;&gt;): Int {
<span class="fc bfc" id="L45" title="All 2 branches covered.">        if (i == courses.size) return 0</span>
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">        if (memo[i][time] != null) {</span>
<span class="nc" id="L47">            return memo[i][time]!!</span>
        }
<span class="fc" id="L49">        var taken = 0</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">        if (time + courses[i][0] &lt;= courses[i][1]) taken = 1 + schedule(courses, i + 1, time + courses[i][0], memo)</span>
<span class="fc" id="L51">        val notTaken = schedule(courses, i + 1, time, memo)</span>
<span class="fc" id="L52">        memo[i][time] = max(taken, notTaken)</span>
<span class="fc" id="L53">        return memo[i][time]!!</span>
    }
}

/**
 * Approach 3: Iterative Solution
 */
<span class="fc" id="L60">class ScheduleCourse3Iterative : ScheduleCourse3 {</span>
    override operator fun invoke(courses: Array&lt;IntArray&gt;): Int {
<span class="fc" id="L62">        courses.sortWith { a: IntArray, b: IntArray -&gt;</span>
<span class="fc" id="L63">            a[1] - b[1]</span>
        }
<span class="fc" id="L65">        var time = 0</span>
<span class="fc" id="L66">        var count = 0</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">        for (i in courses.indices) {</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">            if (time + courses[i][0] &lt;= courses[i][1]) {</span>
<span class="fc" id="L69">                time += courses[i][0]</span>
<span class="fc" id="L70">                count++</span>
            } else {
<span class="fc" id="L72">                var maxI = i</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">                for (j in 0 until i) {</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">                    if (courses[j][0] &gt; courses[maxI][0]) maxI = j</span>
                }
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">                if (courses[maxI][0] &gt; courses[i][0]) {</span>
<span class="nc" id="L77">                    time += courses[i][0] - courses[maxI][0]</span>
                }
<span class="fc" id="L79">                courses[maxI][0] = -1</span>
            }
        }
<span class="fc" id="L82">        return count</span>
    }
}

/**
 * Approach 4: Optimized Iterative
 */
<span class="fc" id="L89">class ScheduleCourse3OptimizedIterative : ScheduleCourse3 {</span>
    override operator fun invoke(courses: Array&lt;IntArray&gt;): Int {
<span class="fc" id="L91">        courses.sortWith { a: IntArray, b: IntArray -&gt;</span>
<span class="fc" id="L92">            a[1] - b[1]</span>
        }
<span class="fc" id="L94">        var time = 0</span>
<span class="fc" id="L95">        var count = 0</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        for (i in courses.indices) {</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">            if (time + courses[i][0] &lt;= courses[i][1]) {</span>
<span class="fc" id="L98">                time += courses[i][0]</span>
<span class="fc" id="L99">                courses[count++] = courses[i]</span>
            } else {
<span class="fc" id="L101">                var maxI = i</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">                for (j in 0 until count) {</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">                    if (courses[j][0] &gt; courses[maxI][0]) maxI = j</span>
                }
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">                if (courses[maxI][0] &gt; courses[i][0]) {</span>
<span class="nc" id="L106">                    time += courses[i][0] - courses[maxI][0]</span>
<span class="nc" id="L107">                    courses[maxI] = courses[i]</span>
                }
            }
        }
<span class="fc" id="L111">        return count</span>
    }
}

/**
 * Approach 5: Extra List
 */
<span class="fc" id="L118">class ScheduleCourse3ExtraList : ScheduleCourse3 {</span>
    override operator fun invoke(courses: Array&lt;IntArray&gt;): Int {
<span class="fc" id="L120">        courses.sortWith { a: IntArray, b: IntArray -&gt;</span>
<span class="fc" id="L121">            a[1] - b[1]</span>
        }
<span class="fc" id="L123">        val validList: MutableList&lt;Int&gt; = ArrayList()</span>
<span class="fc" id="L124">        var time = 0</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        for (c in courses) {</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            if (time + c[0] &lt;= c[1]) {</span>
<span class="fc" id="L127">                validList.add(c[0])</span>
<span class="fc" id="L128">                time += c[0]</span>
            } else {
<span class="fc" id="L130">                var maxI = 0</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">                for (i in 1 until validList.size) {</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">                    if (validList[i] &gt; validList[maxI]) maxI = i</span>
                }
<span class="pc bpc" id="L134" title="1 of 6 branches missed.">                if (validList.isNotEmpty() &amp;&amp; validList[maxI] &gt; c[0]) {</span>
<span class="nc" id="L135">                    time += c[0] - validList[maxI]</span>
<span class="nc" id="L136">                    validList[maxI] = c[0]</span>
                }
            }
        }
<span class="fc" id="L140">        return validList.size</span>
    }
}

/**
 * Approach 6: Priority Queue
 * Time complexity : O(n log n).
 * Space complexity : O(n).
 */
<span class="fc" id="L149">class ScheduleCourse3PriorityQueue : ScheduleCourse3 {</span>
    override operator fun invoke(courses: Array&lt;IntArray&gt;): Int {
<span class="fc" id="L151">        courses.sortWith { a: IntArray, b: IntArray -&gt;</span>
<span class="fc" id="L152">            a[1] - b[1]</span>
        }
<span class="fc" id="L154">        val queue: PriorityQueue&lt;Int&gt; = PriorityQueue { a, b -&gt; b - a }</span>
<span class="fc" id="L155">        var time = 0</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for (c in courses) {</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (time + c[0] &lt;= c[1]) {</span>
<span class="fc" id="L158">                queue.offer(c[0])</span>
<span class="fc" id="L159">                time += c[0]</span>
<span class="pc bpc" id="L160" title="1 of 4 branches missed.">            } else if (!queue.isEmpty() &amp;&amp; queue.peek() &gt; c[0]) {</span>
<span class="nc" id="L161">                time += c[0] - queue.poll()</span>
<span class="nc" id="L162">                queue.offer(c[0])</span>
            }
        }
<span class="fc" id="L165">        return queue.size</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>