<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FurthestBuilding.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">kotlab</a> &gt; <a href="index.source.html" class="el_package">dev.shtanko.algorithms.leetcode</a> &gt; <span class="el_source">FurthestBuilding.kt</span></div><h1>FurthestBuilding.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 Oleksii Shtanko
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.shtanko.algorithms.leetcode

import java.util.PriorityQueue
import java.util.Queue
import kotlin.math.max
import kotlin.math.min

/**
 * Furthest Building You Can Reach
 * @see &lt;a href=&quot;https://leetcode.com/problems/furthest-building-you-can-reach/&quot;&gt;leetcode page&lt;/a&gt;
 */
fun interface FurthestBuilding {
    operator fun invoke(heights: IntArray, bricks: Int, ladders: Int): Int
}

/**
 * Approach 1: Min-Heap
 * Time complexity : O(N log N) or O(N log L).
 * Space complexity : O(N) or O(L).
 */
<span class="fc" id="L37">class MinHeap : FurthestBuilding {</span>
    override operator fun invoke(heights: IntArray, bricks: Int, ladders: Int): Int {
        // Create a priority queue with a comparator that makes it behave as a min-heap.
<span class="fc" id="L40">        val ladderAllocations: Queue&lt;Int&gt; = PriorityQueue { a, b -&gt; a - b }</span>
<span class="fc" id="L41">        var b = bricks</span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">        for (i in 0 until heights.size - 1) {</span>
<span class="fc" id="L43">            val climb = heights[i + 1] - heights[i]</span>
            // If this is actually a &quot;jump down&quot;, skip it.
<span class="fc bfc" id="L45" title="All 2 branches covered.">            if (climb &lt;= 0) {</span>
<span class="fc" id="L46">                continue</span>
            }
            // Otherwise, allocate a ladder for this climb.
<span class="fc" id="L49">            ladderAllocations.add(climb)</span>
            // If we haven't gone over the number of ladders, nothing else to do.
<span class="fc bfc" id="L51" title="All 2 branches covered.">            if (ladderAllocations.size &lt;= ladders) {</span>
<span class="fc" id="L52">                continue</span>
            }
            // Otherwise, we will need to take a climb out of ladder_allocations
<span class="fc" id="L55">            b -= ladderAllocations.remove()</span>
            // If this caused bricks to go negative, we can't get to i + 1
<span class="fc bfc" id="L57" title="All 2 branches covered.">            if (b &lt; 0) {</span>
<span class="fc" id="L58">                return i</span>
            }
        }
        // If we got to here, this means we had enough materials to cover every climb.
<span class="fc" id="L62">        return heights.size - 1</span>
    }
}

/**
 * Approach 2: Max-Heap
 * Time complexity : O(N log N).
 * Space complexity : O(N).
 */
<span class="fc" id="L71">class MaxHeap : FurthestBuilding {</span>
    override operator fun invoke(heights: IntArray, bricks: Int, ladders: Int): Int {
        // Create a priority queue with a comparator that makes it behave as a max-heap.
<span class="fc" id="L74">        val brickAllocations: Queue&lt;Int&gt; = PriorityQueue { a: Int, b: Int -&gt; b - a }</span>
<span class="fc" id="L75">        var b = bricks</span>
<span class="fc" id="L76">        var l = ladders</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">        for (i in 0 until heights.size - 1) {</span>
<span class="fc" id="L78">            val climb = heights[i + 1] - heights[i]</span>
            // If this is actually a &quot;jump down&quot;, skip it.
<span class="fc bfc" id="L80" title="All 2 branches covered.">            if (climb &lt;= 0) {</span>
<span class="fc" id="L81">                continue</span>
            }
            // Otherwise, allocate a ladder for this climb.
<span class="fc" id="L84">            brickAllocations.add(climb)</span>
<span class="fc" id="L85">            b -= climb</span>
            // If we've used all the bricks, and have no ladders remaining, then
            // we can't go any further.
<span class="fc bfc" id="L88" title="All 4 branches covered.">            if (b &lt; 0 &amp;&amp; l == 0) {</span>
<span class="fc" id="L89">                return i</span>
            }
            // Otherwise, if we've run out of bricks, we should replace the largest
            // brick allocation with a ladder.
<span class="fc bfc" id="L93" title="All 2 branches covered.">            if (b &lt; 0) {</span>
<span class="fc" id="L94">                b += brickAllocations.remove()</span>
<span class="fc" id="L95">                l--</span>
            }
        }
        // If we got to here, this means we had enough materials to cover every climb.
<span class="fc" id="L99">        return heights.size - 1</span>
    }
}

/**
 * Approach 3: Binary Search for Final Reachable Building
 * Time complexity : O(N logÂ² N).
 * Space complexity : O(N).
 */
<span class="fc" id="L108">class FinalReachableBuilding : FurthestBuilding {</span>
    override operator fun invoke(heights: IntArray, bricks: Int, ladders: Int): Int {
        // Do a binary search on the heights array to find the final reachable building.
        // Do a binary search on the heights array to find the final reachable building.
<span class="fc" id="L112">        var lo = 0</span>
<span class="fc" id="L113">        var hi: Int = heights.size - 1</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">        while (lo &lt; hi) {</span>
<span class="fc" id="L115">            val mid = lo + (hi - lo + 1) / 2</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">            if (isReachable(mid, heights, bricks, ladders)) {</span>
<span class="fc" id="L117">                lo = mid</span>
            } else {
<span class="fc" id="L119">                hi = mid - 1</span>
            }
        }
<span class="fc" id="L122">        return hi // Note that return lo would be equivalent.</span>
    }

    private fun isReachable(buildingIndex: Int, heights: IntArray, bricks: Int, ladders: Int): Boolean {
        // Make a list of all the climbs we need to do to reach buildingIndex.
<span class="fc" id="L127">        var b = bricks</span>
<span class="fc" id="L128">        var l = ladders</span>
<span class="fc" id="L129">        val climbs: MutableList&lt;Int&gt; = ArrayList()</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        for (i in 0 until buildingIndex) {</span>
<span class="fc" id="L131">            val h1 = heights[i]</span>
<span class="fc" id="L132">            val h2 = heights[i + 1]</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">            if (h2 &lt;= h1) {</span>
<span class="fc" id="L134">                continue</span>
            }
<span class="fc" id="L136">            climbs.add(h2 - h1)</span>
        }
<span class="fc" id="L138">        climbs.sort()</span>

        // And now determine whether or not all of these climbs can be covered with the
        // given bricks and ladders.
<span class="fc bfc" id="L142" title="All 2 branches covered.">        for (climb in climbs) {</span>
            // If there are bricks left, use those.
<span class="fc" id="L144">            when {</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                climb &lt;= b -&gt; {</span>
<span class="fc" id="L146">                    b -= climb</span>
                    // Otherwise, you'll have to use a ladder.
                }

<span class="fc bfc" id="L150" title="All 2 branches covered.">                l &gt;= 1 -&gt; {</span>
<span class="fc" id="L151">                    l -= 1</span>
                    // And if there are no ladders either, we can't reach buildingIndex.
                }

                else -&gt; {
<span class="fc" id="L156">                    return false</span>
                }
            }
        }
<span class="fc" id="L160">        return true</span>
    }
}

/**
 * Approach 4: Improved Binary Search for Final Reachable Building
 * Time complexity : O(N log N).
 * Space complexity : O(N).
 */
<span class="fc" id="L169">class ImprovedFinalReachableBuilding : FurthestBuilding {</span>
    override operator fun invoke(heights: IntArray, bricks: Int, ladders: Int): Int {
        // Make a sorted list of all the climbs.
<span class="fc" id="L172">        val sortedClimbs: MutableList&lt;IntArray&gt; = ArrayList()</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        for (i in 0 until heights.size - 1) {</span>
<span class="fc" id="L174">            val climb = heights[i + 1] - heights[i]</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            if (climb &lt;= 0) {</span>
<span class="fc" id="L176">                continue</span>
            }
<span class="fc" id="L178">            sortedClimbs.add(intArrayOf(climb, i + 1))</span>
        }
<span class="fc" id="L180">        sortedClimbs.sortWith { a: IntArray, b: IntArray -&gt; a[0] - b[0] }</span>

        // Now do the binary search, same as before.
<span class="fc" id="L183">        var lo = 0</span>
<span class="fc" id="L184">        var hi: Int = heights.size - 1</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        while (lo &lt; hi) {</span>
<span class="fc" id="L186">            val mid = lo + (hi - lo + 1) / 2</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">            if (isReachable(mid, sortedClimbs, bricks, ladders)) {</span>
<span class="fc" id="L188">                lo = mid</span>
            } else {
<span class="fc" id="L190">                hi = mid - 1</span>
            }
        }
<span class="fc" id="L193">        return hi // Note that return lo would be equivalent.</span>
    }

    private fun isReachable(buildingIndex: Int, climbs: List&lt;IntArray&gt;, bricks: Int, ladders: Int): Boolean {
<span class="fc" id="L197">        var b = bricks</span>
<span class="fc" id="L198">        var l = ladders</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        for (climbEntry in climbs) {</span>
            // Extract the information for this climb
<span class="fc" id="L201">            val climb = climbEntry[0]</span>
<span class="fc" id="L202">            val index = climbEntry[1]</span>
            // Check if this climb is within the range.
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if (index &gt; buildingIndex) {</span>
<span class="fc" id="L205">                continue</span>
            }
            // Allocate bricks if enough remain; otherwise, allocate a ladder if
            // at least one remains.
<span class="fc" id="L209">            when {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                climb &lt;= b -&gt; {</span>
<span class="fc" id="L211">                    b -= climb</span>
                }

<span class="fc bfc" id="L214" title="All 2 branches covered.">                l &gt;= 1 -&gt; {</span>
<span class="fc" id="L215">                    l -= 1</span>
                }

                else -&gt; {
<span class="fc" id="L219">                    return false</span>
                }
            }
        }
<span class="fc" id="L223">        return true</span>
    }
}

/**
 * Approach 5: Binary Search on Threshold (Advanced)
 * Time complexity : O(N log(maxClimb)).
 * Space complexity : O(1).
 */
<span class="fc" id="L232">class BSThreshold : FurthestBuilding {</span>
    override operator fun invoke(heights: IntArray, bricks: Int, ladders: Int): Int {
<span class="fc" id="L234">        var lo = Int.MAX_VALUE</span>
<span class="fc" id="L235">        var hi = Int.MIN_VALUE</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">        for (i in 0 until heights.size - 1) {</span>
<span class="fc" id="L237">            val climb = heights[i + 1] - heights[i]</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">            if (climb &lt;= 0) {</span>
<span class="fc" id="L239">                continue</span>
            }
<span class="fc" id="L241">            lo = min(lo, climb)</span>
<span class="fc" id="L242">            hi = max(hi, climb)</span>
        }
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (lo == Int.MAX_VALUE) {</span>
<span class="nc" id="L245">            return heights.size - 1</span>
        }
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        while (lo &lt;= hi) {</span>
<span class="fc" id="L248">            val mid = lo + (hi - lo) / 2</span>
<span class="fc" id="L249">            val result = solveWithGivenThreshold(heights, bricks, ladders, mid)</span>
<span class="fc" id="L250">            val indexReached = result[0]</span>
<span class="fc" id="L251">            val laddersRemaining = result[1]</span>
<span class="fc" id="L252">            val bricksRemaining = result[2]</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (indexReached == heights.size - 1) {</span>
<span class="fc" id="L254">                return heights.size - 1</span>
            }
<span class="fc bfc" id="L256" title="All 2 branches covered.">            if (laddersRemaining &gt; 0) {</span>
<span class="fc" id="L257">                hi = mid - 1</span>
<span class="fc" id="L258">                continue</span>
            }
            // Otherwise, check whether this is the &quot;too low&quot; or &quot;just right&quot; case.
<span class="fc" id="L261">            val nextClimb = heights[indexReached + 1] - heights[indexReached]</span>
<span class="pc bpc" id="L262" title="2 of 4 branches missed.">            lo = if (nextClimb &gt; bricksRemaining &amp;&amp; mid &gt; bricksRemaining) {</span>
<span class="fc" id="L263">                return indexReached</span>
            } else {
<span class="nc" id="L265">                mid + 1</span>
            }
        }
<span class="nc" id="L268">        return -1 // It always returns before here. But gotta keep Java happy.</span>
    }

    private fun solveWithGivenThreshold(heights: IntArray, bricks: Int, ladders: Int, k: Int): IntArray {
<span class="fc" id="L272">        var bricksCount = bricks</span>
<span class="fc" id="L273">        var laddersCount = ladders</span>
<span class="fc" id="L274">        var laddersUsedOnThreshold = 0</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">        for (i in 0 until heights.size - 1) {</span>
<span class="fc" id="L276">            val climb = heights[i + 1] - heights[i]</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">            if (climb &lt;= 0) {</span>
<span class="fc" id="L278">                continue</span>
            }
            // Make resource allocations
<span class="fc" id="L281">            when {</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">                climb == k -&gt; {</span>
<span class="fc" id="L283">                    laddersUsedOnThreshold++</span>
<span class="fc" id="L284">                    laddersCount--</span>
                }

<span class="fc bfc" id="L287" title="All 2 branches covered.">                climb &gt; k -&gt; {</span>
<span class="fc" id="L288">                    laddersCount--</span>
                }

                else -&gt; {
<span class="fc" id="L292">                    bricksCount -= climb</span>
                }
            }
            // Handle negative resources
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (laddersCount &lt; 0) {</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">                bricksCount -= if (laddersUsedOnThreshold &gt;= 1) {</span>
<span class="fc" id="L298">                    laddersUsedOnThreshold--</span>
<span class="fc" id="L299">                    laddersCount++</span>
<span class="fc" id="L300">                    k</span>
                } else {
<span class="fc" id="L302">                    return intArrayOf(i, laddersCount, bricksCount)</span>
                }
            }
<span class="fc bfc" id="L305" title="All 2 branches covered.">            if (bricksCount &lt; 0) {</span>
<span class="fc" id="L306">                return intArrayOf(i, laddersCount, bricksCount)</span>
            }
        }
<span class="fc" id="L309">        return intArrayOf(heights.size - 1, laddersCount, bricksCount)</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>